\documentclass[12pt]{article}

\usepackage{german}
\usepackage{geometry}
\usepackage[onehalfspacing]{setspace}

\geometry{
    left=3cm,
    right=3cm,
    top=2.5cm,
    bottom=2.5cm
}

\usepackage{listings}
\usepackage{xcolor}

\usepackage{amsmath}

\usepackage{url}

\setlength{\emergencystretch}{15pt}

\lstset{
    tabsize = 4, %% set tab space width
    showstringspaces = false, %% prevent space marking in strings, string is defined as the text that is generally printed directly to the console
    numbers = left, %% display line numbers on the left
    commentstyle = \color{green}, %% set comment color
    keywordstyle = \color{blue}, %% set keyword color
    stringstyle = \color{red}, %% set string color
    rulecolor = \color{black}, %% set frame color to avoid being affected by text color
    basicstyle = \small \ttfamily , %% set listing font and size
    breaklines = true, %% enable line breaking
    numberstyle = \tiny,
}

\title{Numerisches finden von Nullstellen - Implementierung in Java}
\author{Jakob Rzeppa}

\begin{document}
\begin{titlepage}
	\centering
    {\huge IGSFF LOGO TODO\par}
	{Grünewaldstraße 12a - 38104 Braunschweig - T. 470 5850\par}
	\vspace{1cm}
	{\underline{Seminarfach:}\par}
	\vspace{1cm}
    {\large Facharbeit des Schülers \textit{Jakob Rzeppa} \par mit dem Thema: \par}
    \vspace{1.5cm}
	{\huge Numerisches finden von Nullstellen - Implementierung in Java\par}
	\vspace{2cm}
\end{titlepage}

\tableofcontents

\section{Einleitung}

\subsection{Problemstellung}

\subsection{Verwendungszwecke}

\section{Durand-Kerner-Methode}
Die Weierstraß-Iteration, auch genannt Durand-Kerner-Methode, ist ein iteratives Verfahren, zur numerischen Bestimmung aller komplexen Nullstellen einer univariaten Polynomfunktion.
Sie wurde von Karl Weierstrass zwischen 1859 und 1891, als Teil seines Beweises des Fundermentalsatz der Algebra, entwickelt und 1960 von Durand sowie 1966 von Immo Kerner unabhängig voneinander wiederentwickelt.
Die Weierstraß-Iteration findet die Nullstellen, im Gegensatz zum Newton-Horner-Verfahren\footnote{
    Das Newton-Horner-Verfahren ist eine Kombination der Newton-Methode und des Horner-Schemas. Dabei wird eine Nullstelle mithilfe der Newton-Methode gefunden und dannach mithilfe des Horner-Schemas von der Funktion entfernt. Das Verfahren wird bis alle Nullstellen gefunden wurden wiederholt.
}
, nicht nacheinander, sondern parallel. Das bedeutet, dass bei jedem Schritt jede Nullstelle genauer wird und nicht jede Nullstelle nacheinander approximiert wird.\footnote{
    vgl. Wikipedia: Durand-Kerner method, URL: \url{https://en.wikipedia.org/wiki/Durand-Kerner_method} (Zuletzt eingesehen am 29.10.2023)
    \label{ftn:Wikipedia-Durand-Kerner-Method}
}

%----------------------------------------------------------------------------------------------------
\section{Funktionsweise}
\subsection{Bedingungen}
Für die Durand-Kerner-Methode muss ein normiertes univariates Polynom der Form $p(x) = x^n + a_{n-1} x^{n-1} + \dots + a_1 x + a_0$ gegeben sein. Der Grad $n$ des Polynoms muss größer als zwei sein.\footnote{
    vgl. Wikipedia: Weierstraß-(Durand-Kerner)-Verfahren, URL: \url{https://de.wikipedia.org/wiki/Weierstraß-(Durand-Kerner)-Verfahren} (Zuletzt eingesehen am 29.10.2023)
    \label{ftn:Wikipedia-Weierstraß-Methode}
}

\subsection{Methode}
Bei der Durand-Kerner-Methode wird mit jeder Iteration jede Nullstelle etwas genauer. Dafür werden $n$ Gleichungen für $n$ Nullstellen $z_n;z_{n-1};\dots;z_1$ gebildet. Über diese wird, bis das Endkriterium erreicht ist, iteriert. Dabei ist $i$ die Anzahl der Iterationen und wird pro Iteration um 1 inkrementiert.
\[z_n^{(i+1)} = x - \frac{p(z_n^{(i)})}{\prod_{j=1;j\neq n}^{n}(z_n^{(i)}-z_j)}\]
\[z_{n-1}^{(i+1)} = x - \frac{p(z_{n-1}^{(i)})}{\prod_{j=1;j\neq n-1}^{n}(z_{n-1}^{(i)}-z_j)}\]
\vspace{0.25mm}
\[\dots\]
\[z_{1}^{(i+1)} = x - \frac{p(z_{1}^{(i)})}{\prod_{j=1;j\neq 1}^{n}(z_{1}^{(i)}-z_j)}\]
\subsection{Startpunkte}
Zunächst müssen alle Startpunkte $z_n^{(0)};z_{n-1}^{(0)};\dots;z_1^{(0)}$ gesetzt werden. Das kann zufällig passieren. Es muss jedoch beachtet werden, dass Startpunkte für komplexe Nullstellen auch komplex sein müssen. Außerdem müssen alle Startpunkte unterschiedlich sein, damit bei der ersten Iteration nicht durch null dividiert wird: 
Wenn $z_{k}^{(i)}$ gleich einem anderen $z$ ist, wird bei der Gleichung
\begin{equation*}
    z_k^{(i+1)} = \frac{p(z_{k}^{(i)})}{\prod_{j=1;j\neq k}^{n}(z_{k}^{(i)}-z_j)}
\end{equation*}
durch Null dividiert.
Die Startpunkte können allerdings auch die Anzahl der Iterationen beeinflussen. Deswegen macht es Sinn möglichst nahe an den wahrscheinlichen Nullstellen anzufangen. Eine der gänigsten Methoden ist die Startpunkte in einem Kreis auf der komplexen Ebene zu verteilen. Dabei ist der Radius $r = \sqrt[n]{|a_0|}$ relativ genau. Jedoch ist es sehr ressourcenintensiv mit einem Computer Wurzeln zu berechnen. Deshalb kann auch ein weniger genaueres $r$ genommen werden: $r = |\frac{na_0}{2a_1}| + |\frac{a_{n-1}}{2n}|$.
Das Inkrement $\theta = \frac{2\pi}{n} \text{ bzw. } \frac{360^\circ}{n}$. Mit diesem werden alle Startpunkte gleichmäßig verteilt, indem der Kreis in $n$ Abschnitte geteilt wird, an dessen Anfängen die Startpunkte liegen. Zuletzt wird noch eine Verschiebung $c$ benötigt. Diese kann beliebig gewählt werden, solange keine reellen Zahlen unter den Startpunkten sind. In diesem Fall wird $c = \frac{\pi}{2n}$ gewählt.
Um die Startpunkte zu bestimmen wird 
\[z_{k}^{(0)} = r\cos((k-1)\theta+c)+r\sin((k-1)\theta+c)i \text{ für } k=1;2;\dots;n\]
 angewand.

\subsection{Endkriterium}
Um zu bestimmen, ob eine Nullstelle gefunden wurde gibt es grundsätzlich zwei oft verwendete Verfahren. Bei beiden muss eine Genauigkeit $g$ (z.B. $0,0001$) gegeben sein. 
In dem ersten Verfahren wird die Nullstelle in die Funktion eingesetzt und mit der festgelegten Genauigkeit verglichen. Wenn $p(z_k^{(i)}) < g$ mit $k=n;n-1;\dots ;1$ in jedem Fall wahr ist kann geschlossen werden, dass alle Nullstellen für die gegebene Genauigkeit gefunden wurden. Allerdings hat dieses Verfahren einen Fehler. Selten kann es passieren, dass die Funktion an manchen Stellen sehr nah an null ist, so dass an mehreren Stellen die Bedingungen erreicht sind. Das kann zu großen Ungenauigkeiten führen. Das zweite Verfahren vergleicht die Differenz zwischen den letzten beiden Schritten mit der Genauigkeit. Wenn $|z_k^{(i-1)}z_k^{(i)}| < g$ mit $k=n;n-1;\dots ;1$ in jedem Fall wahr ist kann geschlossen, dass alle Nullstellen auf die Genauigkeit $g$ genau sind. Bei dieser Methode kann es jedoch vorkommen, wenn die Funktion nach oder vor der Nullstelle sehr stark steigt oder fällt, dass wenn der Wert in die Funktion eingegeben wird ein Wert ungleich null herrauskommt. Allerdings ist man in jedem Fall um die Genauigkeit $g$ genau an der Nullstelle.\\\\
In der folgenden Implementierung der Durand-Kerner-Methode wurde das zweite Verfahren benutzt, da dies einem die Nullstelle mit der gewünschten Genauigkeit zuverlässiger gibt. Auch wenn diese in der Funktion eingesetzt etwas anderes ergeben könnte ist man immer um die gewünschte Genauigkeit nah an der Nullstelle. Das ist bei der ersten Methode nicht immer der Fall.

%-----------------------------------------------------------------------------------------------------------
\section{Beispiel}
Im nächsten Abschnitt wird die Durand-Kerner-Methode an einer Polynomfunktion vierten Grades beispielhaft durchgeführt. Dabei wird die Genauigkeit im Beispiel auf vier Nachkommastellen begrenzt, was zu Ungenauigkeiten kleiner als $0,0001$ führen kann.
\paragraph{Methode}
Für die Funktion $p(x) = x^4 + 4x^3 - 2x^2 + 3x - 4 = (x-s)(x-t)(x-u)(x-v)$ sind die Nullstellen $s;t;u;v \in C$ gesucht. Auf jede der Nullstellen wird die zuvor beschriebene Methode angewendet:
\begin{equation*}
    s_{n+1} = s_n-\frac{f(s_n)}{(s_n-t_n)(s_n-u_n)(s_n-v_n)}
\end{equation*}
\begin{equation*}
    t_{n+1} = t_n-\frac{f(t_n)}{(t_n-s_n)(t_n-u_n)(t_n-v_n)}
\end{equation*}
\begin{equation*}
    u_{n+1} = u_n-\frac{f(u_n)}{(u_n-s_n)(u_n-t_n)(u_n-v_n)}
\end{equation*}
\begin{equation*}
    v_{n+1} = v_n-\frac{f(v_n)}{(v_n-s_n)(v_n-t_n)(v_n-u_n)}
\end{equation*}
\paragraph{Startpunkte}
Zuvor müssen allerdings die Startpunkte $s_0;t_0;u_0;v_0$ bestimmt werden. Dabei ist der Radius des Kreises $r = |\frac{na_0}{2a_1}| + |\frac{a_{n-1}}{2na_n}| = \frac{19}{6}$, der Abstand zwischen den Startpunkten $\theta = \frac{2\pi}{n} = \frac{1}{2}\pi$ und die Verschiebung $c = \frac{\pi}{2n} = \frac{1}{8}\pi$. Mit diesen Werten können die Startpunkte berechnet werden. \\
$s_0 = r \cos(c) + r \sin(c)i = 2,9256 + 1,2118i$ \\
$t_0 = r \cos(\theta+c) + r \sin(\theta+c)i = -1,2118 + 2,9256i$ \\
$u_0 = r \cos(2\theta+c) + r \sin(2\theta+c)i = -2,9256 - 1,2118i$ \\
$v_0 = r \cos(3\theta+c) + r \sin(3\theta+c)i = 1,2118 - 2,9256i$

\paragraph{Ausführung}
\begin{center}
\begin{tabular}{c|c c c c}
    Iteration & r & s & t & u \\
    \hline
    0 & 2,9256 + 1,2118i & -1,2118 + 2,9256i & -2,9256 - 1,2118i & 1,2118 - 2,9256i \\
    1 & 1,2993 + 0,8722i & -1,8873 + 2,0075i & -3,405 - 0,7665i & -0,0069 - 2,1133i \\
    2 & 1,0806 + 0,5889i & -1,1784 + 0,4767i & -4,1287 + 0,3433i & 0,2265 - 1,4089 \\
    3 & 0,7884 + 0,3817i & -0,2138 + 0,7292i & -4,6806 - 0,0989 & 0,1061 - 1,012i \\
    4 & 0,6759 - 0,234i & 0,0243 + 0,9804i & -4,613 - 0,0021i & -0,0872 - 0,9549i \\
    5 & 0,8621 + 0,0197i & -0,1294 + 0,9945i & -4,6149 & -0,1177 - 1,0141i \\
    6 & 0,842 + 0,0004i & -0,1134 + 1,0078i & -4,6149 & -0,1136 - 1,0082i \\
    7 & 0,8421 & -0,1136 + 1,0081i & -4,6149 & -0,1136 - 1,0081 \\
    8 & 0,8421 & -0,1136 + 1,0081i & -4,6149 & -0,1136 - 1,0081 \\
\end{tabular}
\end{center}
\paragraph{Endkriterium}
Zwischen Iteration acht und neun bleiben die Werte gleich. Damit ist das Endkriterium erreicht und die Durand-Kerner-Meethod abgeschlossen. 
Die Nullstellen der Polynomfunktion $f(x) = x^4 + 4x^3 - 2x^2 + 3x - 4$ sind bei ca. $0,8421; -4,6149; -0,1136 - 1,0081i; -0,1136 + 1,0081$. 
\paragraph{Probe}
Zur Überpfüfung kann jeder der Werte in $p(x)$ eingesetzt werden.
\begin{displaymath}
    f(0,8421) \approx 0; p(-4,6149) \approx 0; f(-0,1136 - 1,0081i) \approx 0; p(-0,1136 + 1,0081i) \approx 0
\end{displaymath}
Daraus kann geschlossen werden, dass alle vier Werte Annährungen der Nullstellen der Polynomfunktion $p(x)$ sind. \\
Weiterhin, kann aus dem Fundermentalsatz der Algebra hergeleitet werden, dass alle Nullstellen von $p(x)$ gefunden wurden, da $n$ gleich der Anzahl der gefunden Nullstellen ist. \\
$\Rightarrow$ Die Durand-Kerner-Methode war für $p(x)$ erfolgreich.

\section{Visualisierung}
TODO

%--------------------------------------------------------------
\section{Herleitung}
\subsection{Methode}
TODO

\subsection{Wählen der Startpunkte}
Komplexe Nullstellen treten immer in konjugierten Paaren\footnote{Hochschule-Esslingen: Konjugiert komplexe Zahlen (S. 4), URL: \url{https://www2.hs-esslingen.de/~ulmet/mathe/vorlesungen/komplex.pdf} (Zuletzt eingesehen am 29.10.2023)} auf.\footnote{arndt-bruenner.de: Nullstellen von Polynomen in der komplexen Zahlenebene, URL: \url{https://www.arndt-bruenner.de/mathe/scripts/polynullview.htm#:~:text=NullstellenvonPolynomeninderkomplexenZahlenebene&text=KomplexeNullstellentretenimmerals,imVorzeichenunterschiedlichenimaginärenAnteil.} (Zuletzt eingesehen am 23.10.2023)} \\

Erster Satz von Cauchy
https://didaktik.mathematik.hu-berlin.de/user/fehlingerl/Helga.pdf

%------------------------------------------------------------------------------------
\section{Probleme und Einschränkungen}
\subsection{Normiertes Polynom}
Für die Durand-Kerner-Methode muss die gegebene Funktion $p(x)$ in der Form $\prod_{i=1}^n (x-z_i)$ dargestellt werden können. Da $\prod_{i=1}^n (x-z_i)$ ausmultipliziert, in jedem Fall ein normiertes Polynom ergibt, muss $p(x)$ für die Durand-Kerner-Methode ein normiertes Polynom sein.
Ist dies nicht der Fall, wird es unmöglich, $p(x)$ in der Form $\prod_{i=1}^n (x-z_i)$ darzustellen. Daraus folgt, dass man die Methode ohne Umwege nicht ausführen kann. \\
Allerdings gibt es eine einfache Lösung für dieses Problem. Wenn man eine Funktion gleich null setzt, kann man beide Seiten mit einer beliebigen Zahl multiplizieren. Dabei verändert sich das Ergebnis nicht, da $0m = 0$ \space $\forall m$ ist. Daraus folgt, dass sich die Nullstellen eines Polynoms, wenn dieses mit einer beliebigen Zahl multipliziert wird, nicht verändern. \\
Somit kann man das Polynom, dessen Nullstellen man finden möchte, durch $a_n$ teilen und bekommt ein normiertes Polynom mit den gleichen Nullstellen. Mit diesem kann man dann die Durand-Kerner-Methode durchführen.

\subsection{Keine generelle Konvergenz?}
Die Durand-Kerner-Methode ist nicht generell Konvergent. Das bedeutet, dass in manchen Fällen die Funktion gegen Unendlich keinen festen Wert anstrebt. Das kann man sich so vorstellen: Jede Nullstelle hat einen Bereich in dem sie von der Weierstraß-Iteration gefunden werden kann. Dieser kann auch ins Unendliche gehen, muss aber nicht. Wenn eine Iteration außerhalb dieses Bereiches geht findet der Wert nicht mehr zu der Nullstelle. Dadurch können auch die anderen Nullstellen nicht konvergieren, da eine der Nullstellen so falsch ist, dass die Korrektur nicht mehr funktioniert. Das führt dazu, dass die Methode nicht konvergiert. Dabei kann nicht generell bestimmt werden, bei welchen Startpunkten und Polynomen die Durand-Kerner-Methode nicht konvergiert. Da dies allerdings sehr selten ist kann es meist vernachlässigt werden.

\section{Implementierung}
\subsection{Einleitung}
Normierung
\subsection{Komplexe Zahlen}
In Java gibt es keinen eingebauten Weg mit komplexen Zahlen zu rechnen. Es ist möglich mithilfe einer Bibliothek komplexe Zahlen nutzen zu können, es ist jedoch nicht gegeben, dass alle nötigen Operationen eingebaut sind. Deshalb habe ich mich dazu entschieden eine eigene Klasse \glqq Complex\grqq zu schreiben, um volle Kontrolle über die Methoden und Implementierung der komplexen Zahlen zu haben.

\paragraph{Aufbau der Klasse}
Die Klasse \glqq Complex\glqq\space besitzt zwei Attribute einen Konstruktor und mehrere statische und nicht statische Funktionen. Außerdem ist die \glqq toString\glqq-Methode überschrieben und die Methode zum runden implementiert. Alle Attribute sind \glqq private\grqq, da sie von außerhalb nicht benötigt werden und jede Methode \glqq public\glqq, da diese auch von Außerhalb aufgerufen werden.

\paragraph{Attribute}
Beide Attribute sind vom Datentyp \glqq double\grqq, um möglichst genaue und große Dezimalzahlen darstellen zu können. Sie stellen den reellen und imaginären Teil dar. Dabei steht \glqq re\grqq\space für die reellen und \glqq im\grqq\space für die imaginären Zahlen.

\paragraph{Konstruktor}
Der Konstruktor nimmt den reellen und imaginären Teil entgegen und speichert diese in den Attributen.

\paragraph{Hilfsfunktionen}
Die vier Hilfsfunktionen für die Grundrechenarten Addition, Subtraktion, Multiplikation und Division\footnote{ingenieurkurse.de: Grundrechenarten der komplexen Zahlen, URL: \url{https://www.ingenieurkurse.de/hoehere-mathematik-analysis-lineare-algebra/komplexe-zahlen/grundrechenarten-der-komplexen-zahlen.html} (Zuletzt eingesehen: 26.10.2023)\label{ftn:grundrechenarten}} nehmen zwei komplexe Zahlen (Instanzen der Klasse \glqq Complex\grqq) entgegen und geben das Ergebnis zurück. 
Außerdem gibt es eine Hilfsfunktionen für das Potenzieren. Diese nimmt eine komplexe Zahl als Basis und ein Integer als Exponent entgegen. Zuerst wird geguckt, ob der Exponent positiv oder null ist, da negative Potenzierung nicht implementiert ist. Ist das nicht der Fall wird eine \glqq RuntimeException\grqq, mit passender Fehlermeldung, ausgelöst. Dannach wird, falls der Exponent null ist, 1 als komplexe Zahl zurückgegeben. Sonst wird, mithilfe eine \glqq for-Schleife\grqq, das Ergebnis ausgerechnet.

\paragraph{Betrag}
Die nicht statische Funktion \glqq abs()\grqq\space (kurz für Absolutbetrag) gibt den Betrag der Instanz als \glqq double\grqq\space zurück. Dieser ist für komplexe Zahlen als $|z| := \sqrt{x^2+y^2}$ definiert.\footref{ftn:grundrechenarten}

\paragraph{Runden}
Die Methode \glqq round()\grqq\space gibt eine neue komplexe Zahl zurück, bei welcher der reelle und imaginäre Teil auf vier Nachkommastellen gerundet wurden.

\paragraph{\glqq toString\grqq-Methode}
Die \glqq toString\grqq-Methode wird in der Klasse \glqq Complex\grqq\space überschrieben, um die komplexe Zahl als String zurückzugegeben.

%-----------------------------------------------------------------------------------------
\subsection{Polynomfunktion}
Für die Durand-Kerner-Methode muss eine Polynomfunktion gegeben sein. Diese wird in meiner Implementierung in eine eigene Klasse ausgelagert.

\paragraph{Aufbau der Klasse}
Die Klasse \glqq Poly\grqq\space (kurz für Polynomial (englisch) bzw. Polynom (deutsch)) besitzt zwei Attribute, einen Konstruktor und die Funktion \glqq solve()\grqq. Außerdem wurde die \glqq toString\grqq -Methode überschrieben.

\paragraph{Attribute}
Bei dem ersten Attribut \glqq coefficients\grqq\space handelt es sich um die Koeffizienten. Diese werden in einem Array gespeichert, wo der Index den Exponenten des Terms beschreibt. Das zweite Attribut ist der Grad der Funktion. Beide Attribute sind \glqq public\grqq, da auf diese von Außerhalb zugegriffen wird.

\paragraph{Konstruktor}
Dem Konstruktor muss ein Array der Koeffizienten, wie bei den Attributen beschrieben, übergeben werden. Dieses wird in dem Attribut \glqq coefficients\grqq\space gespeichert. Infolge dessen wird der Grad des Polynoms bestimmt, indem die Länge des Arrays minus eins gerechnet wird.

\paragraph{Lösen der Polynomfunktion}
Das Lösen des Polynoms wird in der Methode \glqq solve()\grqq\space implementiert. Diese ist \glqq public\grqq, weil von Außerhalb auf die Funktion zugegriffen wird. 

\paragraph{Normieren}

\section{Fazit}

\section{Code}

\begin{lstlisting}[language=Java, title={Complex.java: Z. 19-29}]
    public static Complex plus(Complex a, Complex b) {
            double re = a.re + b.re;
            double im = a.im + b.im;
        return new Complex(re, im);
    }
    
    public static Complex minus(Complex a, Complex b) {
        double re = a.re - b.re;
        double im = a.im - b.im;
        return new Complex(re, im);
    }
    \end{lstlisting}
    
\end{document}