\documentclass[12pt]{article}

\usepackage{german}
\usepackage{geometry}
\usepackage[onehalfspacing]{setspace}

\geometry{
    left=3cm,
    right=3cm,
    top=2.5cm,
    bottom=2.5cm
}

\usepackage{listings}
\usepackage{xcolor}

\usepackage{amsmath}

\usepackage{url}

\setlength{\emergencystretch}{15pt}

\lstset{
    tabsize = 4, %% set tab space width
    showstringspaces = false, %% prevent space marking in strings, string is defined as the text that is generally printed directly to the console
    numbers = left, %% display line numbers on the left
    commentstyle = \color{green}, %% set comment color
    keywordstyle = \color{blue}, %% set keyword color
    stringstyle = \color{red}, %% set string color
    rulecolor = \color{black}, %% set frame color to avoid being affected by text color
    basicstyle = \small \ttfamily , %% set listing font and size
    breaklines = true, %% enable line breaking
    numberstyle = \tiny,
}

\title{Numerisches finden von Nullstellen - Implementierung in Java}
\author{Jakob Rzeppa}

\begin{document}
\begin{titlepage}
	\centering
    {\huge IGSFF LOGO TODO\par}
	{Grünewaldstraße 12a - 38104 Braunschweig - T. 470 5850\par}
	\vspace{1cm}
	{\underline{Seminarfach:}\par}
	\vspace{1cm}
    {\large Facharbeit des Schülers \textit{Jakob Rzeppa} \par mit dem Thema: \par}
    \vspace{1.5cm}
	{\huge Numerisches finden von Nullstellen - Implementierung in Java\par}
	\vspace{2cm}
\end{titlepage}

\tableofcontents

\section{Einleitung}

\subsection{Problemstellung}

\subsection{Verwendungszwecke}


\section{Durand-Kerner-Methode}
Die Durand-Kerner-Methode, auch genannt Weierstrass-Methode, ist ein iteratives Verfahren, zur numerischen Bestimmung aller komplexen Nullstellen einer univariaten Polynomfunktion.
Sie wurde von Karl Weierstrass zwischen 1859 und 1891, als Teil seines Beweises des Fundermentalsatz der Algebra, entwickelt und 1960 von Durand sowie 1966 von Immo Kerner unabhängig voneinander wiederentwickelt.
Die Durand-Kerner-Methode findet die Nullstellen, im Gegensatz zum Newton-Horner-Verfahren\footnote{
    Das Newton-Horner-Verfahren ist eine Kombination der Newton-Methode und des Horner-Schemas. Dabei wird eine Nullstelle mithilfe der Newton-Methode gefunden und dannach mithilfe des Horner-Schemas von der Funktion entfernt. Das Verfahren wird bis alle Nullstellen gefunden wurden wiederholt.
}
, nicht nacheinander, sondern parallel. Das bedeutet, dass bei jedem Schritt jede Nullstelle genauer wird und nicht jede Nullstelle nacheinander approximiert wird.\footnote{

}

%----------------------------------------------------------------------------------------------------
\section{Funktionsweise}
\subsection{Bedingungen}
Für die Durand-Kerner-Methode muss ein normiertes univariates Polynom der Form $p(x) = x^n + a_{n-1} x^{n-1} + \dots + a_1 x + a_0$ gegeben sein. Der Grad $n$ des Polynoms muss größer als zwei sein.

\subsection{Methode}
Bei der Durand-Kerner-Methode wird mit jeder Iteration jede Nullstelle etwas genauer. Dafür werden $n$ Gleichungen für $n$ Nullstellen $z_n;z_{n-1};\dots;z_1$ gebildet. Über diese wird, bis das Endkriterium erreicht ist, iteriert. Dabei ist $i$ die Anzahl der Iterationen und wird pro Iteration um 1 inkrementiert.
\[z_n^{(i+1)} = x - \frac{p(z_n^{(i)})}{\prod_{j=1;j\neq n}^{n}(z_n^{(i)}-z_j)}\]
\[z_{n-1}^{(i+1)} = x - \frac{p(z_{n-1}^{(i)})}{\prod_{j=1;j\neq n-1}^{n}(z_{n-1}^{(i)}-z_j)}\]
\vspace{0.25mm}
\[\dots\]
\[z_{1}^{(i+1)} = x - \frac{p(z_{1}^{(i)})}{\prod_{j=1;j\neq 1}^{n}(z_{1}^{(i)}-z_j)}\]
\subsection{Startpunkte}
Zunächst müssen alle Startpunkte $z_n^{(0)};z_{n-1}^{(0)};\dots;z_1^{(0)}$ gesetzt werden. Das kann zufällig passieren. Es muss jedoch beachtet werden, dass Startpunkte für komplex Nullstellen auch komplex sind und keine konjugierten Paare\footnote{Konjugierte Paare sind Paare von komplexen Zahlen, welche sich nur im Vorzeichen des imaginären Teils unterscheiden. !!!FUßNOTE!!!} vorkommen. Die Startpunkte können allerdings die Anzahl der Iterationen beeinflussen. Deswegen macht es Sinn möglichst nahe an den wahrscheinlichen Nullstellen anzufangen. Eine der gänigsten Methoden ist die Startpunkte in einem Kreis auf der komplexen Ebene zu verteilen. Dabei ist der Radius $r = \sqrt[n]{|a_0|}$ relativ genau. Jedoch ist es sehr ressourcenintensiv mit einem Computer Wurzeln zu berechnen. Deshalb kann auch ein weniger genaueres $r$ genommen werden: $r = |\frac{na_0}{2a_1}| + |\frac{a_{n-1}}{2n}|$.
Das Inkrement $\theta = \frac{2\pi}{n} \text{ bzw. } \frac{360^\circ}{n}$. Mit diesem werden alle Startpunkte gleichmäßig verteilt, indem der Kreis in $n$ Abschnitte geteilt wird, an dessen Anfängen die Startpunkte liegen. Zuletzt wird noch eine Verschiebung $c$ benötigt. Diese kann beliebig gewählt werden, solange keine reellen Zahlen unter den Startpunkten sind. In diesem Fall wird $c = \frac{\pi}{2n}$ gewählt.
Um die Startpunkte zu bestimmen wird 
\[z_{k}^{(0)} = r\cos((k-1)\theta+c)+r\sin((k-1)\theta+c)i \text{ für } k=1;2;\dots;n\]
 angewand.

\subsection{Endkriterium}
Um zu bestimmen, ob eine Nullstelle gefunden wurde gibt es grundsätzlich zwei oft verwendete Verfahren. Bei beiden muss eine Genauigkeit $g$ gegeben sein. 
In dem ersten Verfahren wird die Nullstelle in die Funktion eingesetzt und mit der festgelegten Genauigkeit verglichen. Wenn $p(z_k^{(i)}) < g$ mit $k=n;n-1;\dots ;1$ in jedem Fall wahr ist kann geschlossen werden, dass alle Nullstellen für die gegebene Genauigkeit gefunden wurden. Allerdings hat dieses Verfahren einen Fehler. Selten kann es passieren, dass die Funktion nach oder vor der Nullstelle so langsam steigt oder fällt, dass in einem größeren Bereich die Bedingungen erreicht sind. Das kann zu großen Ungenauigkeiten führen. Das zweite Verfahren vergleicht die Differenz zwischen den letzten beiden Schritten mit der Genauigkeit. Wenn $|z_k^{(i-1)}z_k^{(i)}| < g$ mit $k=n;n-1;\dots ;1$ in jedem Fall wahr ist kann geschlossen, dass alle Nullstellen auf die Genauigkeit $g$ genau sind. Bei dieser Methode kann es jedoch vorkommen, wenn die Funktion nach oder vor der Nullstelle sehr stark steigt oder fällt, dass wenn man den Wert in die Funktion eingibt ein ganz anderes Ergebnis herauskommt. In der folgenden Implementierung der Durand-Kerner-Methode wurde das zweite Verfahren benutzt, da dies einem die Nullstelle mit der gewünschten Genauigkeit gibt. Auch wenn diese in der Funktion eingesetzt etwas anderes ergeben könnte. Die Wahrscheinlichkeit, dass das passiert, solange man eine vernünftige Genauigkeit nimmt, ist allerdings verschwindend gering. 

%-----------------------------------------------------------------------------------------------------------
\section{Beispiel}
Im nächsten Abschnitt wird die Durand-Kerner-Methode an einer Polynomfunktion vierten Grades beispielhaft durchgeführt. Dabei wird die Genauigkeit im Beispiel auf vier Nachkommastellen begrenzt, was zu Ungenauigkeiten kleiner als $0,0001$ führen kann.
\paragraph{Methode}
Für die Funktion $p(x) = x^4 + 4x^3 - 2x^2 + 3x - 4 = (x-s)(x-t)(x-u)(x-v)$ sind die Nullstellen $s;t;u;v \in C$ gesucht. Auf jede der Nullstellen wird die zuvor beschriebene Methode angewendet:
\begin{equation*}
    s_{n+1} = s_n-\frac{f(s_n)}{(s_n-t_n)(s_n-u_n)(s_n-v_n)}
\end{equation*}
\begin{equation*}
    t_{n+1} = t_n-\frac{f(t_n)}{(t_n-s_n)(t_n-u_n)(t_n-v_n)}
\end{equation*}
\begin{equation*}
    u_{n+1} = u_n-\frac{f(u_n)}{(u_n-s_n)(u_n-t_n)(u_n-v_n)}
\end{equation*}
\begin{equation*}
    v_{n+1} = v_n-\frac{f(v_n)}{(v_n-s_n)(v_n-t_n)(v_n-u_n)}
\end{equation*}
\paragraph{Startpunkte}
Zuvor müssen allerdings die Startpunkte $s_0;t_0;u_0;v_0$ bestimmt werden. Dabei ist der Radius des Kreises $r = |\frac{na_0}{2a_1}| + |\frac{a_{n-1}}{2na_n}| = \frac{19}{6}$, der Abstand zwischen den Startpunkten $\theta = \frac{2\pi}{n} = \frac{1}{2}\pi$ und die Verschiebung $c = \frac{\pi}{2n} = \frac{1}{8}\pi$. Mit diesen Werten können die Startpunkte berechnet werden. \\
$s_0 = r \cos(c) + r \sin(c)i = 2,9256 + 1,2118i$ \\
$t_0 = r \cos(\theta+c) + r \sin(\theta+c)i = -1,2118 + 2,9256i$ \\
$u_0 = r \cos(2\theta+c) + r \sin(2\theta+c)i = -2,9256 - 1,2118i$ \\
$v_0 = r \cos(3\theta+c) + r \sin(3\theta+c)i = 1,2118 - 2,9256i$

\paragraph{Ausführung}
\begin{center}
\begin{tabular}{c|c c c c}
    Iteration & r & s & t & u \\
    \hline
    0 & 2,9256 + 1,2118i & -1,2118 + 2,9256i & -2,9256 - 1,2118i & 1,2118 - 2,9256i \\
    1 & 1,2993 + 0,8722i & -1,8873 + 2,0075i & -3,405 - 0,7665i & -0,0069 - 2,1133i \\
    2 & 1,0806 + 0,5889i & -1,1784 + 0,4767i & -4,1287 + 0,3433i & 0,2265 - 1,4089 \\
    3 & 0,7884 + 0,3817i & -0,2138 + 0,7292i & -4,6806 - 0,0989 & 0,1061 - 1,012i \\
    4 & 0,6759 - 0,234i & 0,0243 + 0,9804i & -4,613 - 0,0021i & -0,0872 - 0,9549i \\
    5 & 0,8621 + 0,0197i & -0,1294 + 0,9945i & -4,6149 & -0,1177 - 1,0141i \\
    6 & 0,842 + 0,0004i & -0,1134 + 1,0078i & -4,6149 & -0,1136 - 1,0082i \\
    7 & 0,8421 & -0,1136 + 1,0081i & -4,6149 & -0,1136 - 1,0081 \\
    8 & 0,8421 & -0,1136 + 1,0081i & -4,6149 & -0,1136 - 1,0081 \\
\end{tabular}
\end{center}
\paragraph{Endkriterium}
Zwischen Iteration acht und neun bleiben die Werte gleich. Damit ist das Endkriterium erreicht und die Durand-Kerner-Meethod abgeschlossen. 
Die Nullstellen der Polynomfunktion $f(x) = x^4 + 4x^3 - 2x^2 + 3x - 4$ sind bei ca. $0,8421; -4,6149; -0,1136 - 1,0081i; -0,1136 + 1,0081$. 
\paragraph{Probe}
Zur Überpfüfung kann jeder der Werte in $p(x)$ eingesetzt werden.
\begin{displaymath}
    f(0,8421) \approx 0; p(-4,6149) \approx 0; f(-0,1136 - 1,0081i) \approx 0; p(-0,1136 + 1,0081i) \approx 0
\end{displaymath}
Daraus kann geschlossen werden, dass alle vier Werte Annährungen der Nullstellen der Polynomfunktion $p(x)$ sind. \\
Weiterhin, kann aus dem Fundermentalsatz der Algebra hergeleitet werden, dass alle Nullstellen von $p(x)$ gefunden wurden, da $n$ gleich der Anzahl der gefunden Nullstellen ist. \\
$\Rightarrow$ Die Durand-Kerner-Methode war für $p(x)$ erfolgreich.

\section{Visualisierung}

\section{Herleitung}
\subsection{Interpretation der Weierstraß-Iteration als mehrdimensionales Newton-Verfahren}
Die Weierstraß-Iteration kann als mehrdimensionales Newton-Verfahren verstanden werden. Daraus ergibt sich die (wenigstens lokale) Konvergenz der Methode: \\
Für jedes $n$-Tupel komplexer Zahlen gibt es genau ein normiertes Polynom des Grades $n$, das diese als Nullstellen $z_1;z_2;\dots;z_n$ hat. Das Polynom bekommt man durch das multiplizieren der jeweiligen linearen Faktoren. Daraus folgt, dass, für den Vektor\footnote{Dieser $n$-dimensionelle Vektor kann in diesem Fall zur Vereinfachung mehr als eine Liste der Nullstellen angesehen werden. Es geht weniger um eine Bewegung im Raum, sondern um die einzelnen Nullstellen.} $\vec{z} = (z_1;z_2;\dots;z_n)$, die Gleichung
\begin{equation}
    g_{\vec{z}}(x)=\prod_{j=1}^{n}(x-z_j)=p(x)
\end{equation}
gilt. Bei der Weierstraß-Iteration wird mit jeder Iteration sich an die Nullstelle um die Korrektur $\vec{w} = (w_1;w_2;\dots;w_n)$ angenähert.
\begin{equation}
    g_{\vec{z} + \vec{w}}(x)=\prod_{j=1}^{n}(x-(z_j+w_j))=\prod_{j=1}^{n}(x-z_j-w_j)=p(x)
\end{equation}
Da $\vec{z}$ der Vektor für die Nullstellen ist und keine Korrektur mehr folgen muss ist $\vec{w} = \vec{0}$. Daraus folgt, dass Gleichung (1) und (2) gleich sind. \\\\
Die Taylor-Entwicklung erster Ordnung\footnote{} für den Wert $\vec{z} + \vec{w}$ der Gleichung (2) ergibt:
\begin{equation}
    T_1[g_{\vec{z} + \vec{w}}(x);\vec{z} + \vec{w}] = g_{\vec{z} + \vec{w}}(x)+g_{\vec{z} + \vec{w}}'(x)\cdot (-\vec{w}) = p(x)
\end{equation}
Da Gleichung (1) und (2) gleich sind kann (3) zu
\begin{equation}
    T_1[g_{\vec{z} + \vec{w}}(x);\vec{z} + \vec{w}] = g_{\vec{z}}(x)+g_{\vec{z}}'(x)\cdot (-\vec{w}) = p(x)
\end{equation}
umgeschrieben werden. Die Ableitung von $g_{\vec{z}}(x)$ kann mithilfe der Produktregel gebildet werden.
\begin{align*}
    g_{\vec{z}}'(x) &= (\prod_{j=1}^{n}(x-z_j))' \\
                    &= ((x-z_n)(x-z_{n-1})\dots(x-z_1))' \\
                    &= \sum_{k=1}^{n}\prod_{j=1;j\neq k}^{n}(x-z_j)
\end{align*}
$g_{\vec{z}}(x)$ kann jetzt in die Gleichung (4) eingesetzt werden:
\begin{align*}
    T_1[g_{\vec{z} + \vec{w}}(x);\vec{z} + \vec{w}] &= g_{\vec{z}}(x)+g_{\vec{z}}'(x)\cdot (-\vec{w}) \\
                                                    &= g_{\vec{z}}(x)+\sum_{k=1}^{n}\prod_{j=1;j\neq k}^{n}(x-z_j)\cdot (-\vec{w}) \\
                                                    &= g_{\vec{z}}(x)-\sum_{k=1}^{n}\vec{w}\prod_{j=1;j\neq k}^{n}(x-z_j) \\
                                                    &= p(x)
\end{align*}
Wird jetzt die Nullstelle $x=z_k$ in die Gleichungen
\begin{equation}
    g_{\vec{z}}(x)-\sum_{k=1}^{n}\vec{w}\prod_{j=1;j\neq k}^{n}(x-z_j) = p(x)
\end{equation}
eingesetzt, kann durch Umformungen der Korrekturwert $w_k$ bestimmt werden:
\begin{equation*}
    g_{\vec{z}}(z_k)-\sum_{k=1}^{n}\vec{w}\prod_{j=1;j\neq k}^{n}(z_k-z_j) = g_{\vec{z}}(z_k)-\vec{w}_k\prod_{j=1;j\neq k}^{n}(z_k-z_j) = p(z_k)
\end{equation*}
Da $z_k$ eine Nullstelle ist, ist $g_{\vec{z}}(z_k) = 0$.
\begin{equation*}
    -\vec{w}_k\prod_{j=1;j\neq k}^{n}(z_k-z_j) = p(z_k)
\end{equation*}
\begin{align*}
    &\Leftrightarrow -\vec{w}_k = \frac{p(z_k)}{\prod_{j=1;j\neq k}^{n}(z_k-z_j)} \\
    &\Leftrightarrow \vec{w}_k = -\frac{p(z_k)}{\prod_{j=1;j\neq k}^{n}(z_k-z_j)} \\
    &\Leftrightarrow \vec{w}_k = -\frac{p(z_k)}{g_{\vec{z}}'(z_k)}
\end{align*}
Wenn man diesen Korrekturwert $-\frac{p(z_k)}{g_{\vec{z}}'(x)}$ mit der Korrektur $-\frac{f(x)}{f'(x)}$ bei der Newton-Methode vergleicht, kann man sehen, wie die Weierstraß-Iteration, ähnlich wie die Newton-Methode, Tangenten bildet und über diese die Nullstellen approximiert. Dabei kann die Weierstraß-Iteration als eine mehrdimensionale Newton-Methode verstehen, da diese das gleiche Verfahren, nur mit mehreren Nullstellen gleichzeitig ausführt.\footnote{vgl. Wikipedia: Begründung als Newton-Verfahren, URL: \url{https://de.wikipedia.org/wiki/Weierstraß-(Durand-Kerner)-Verfahren#Begründung_als_Newton-Verfahren}}

\subsection{Startpunkte}
Um zu verstehen, wo sich die Nullstellen am öftesten befinden macht es sinn sich die Verteilung aller Nullstellen eines Polynoms grafisch vorzustellen. 
%Bild
Dazu wird jedem Wert eine Farbe nach

\subsection{Endkriterium}
-Welches der zwei verfahren beesser ist

\section{Probleme und Einschränkungen}
\subsection{Normiertes Polynom}
Für die Durand-Kerner-Methode muss die gegebene Funktion $p(x)$ in der Form $\prod_{i=1}^n (x-z_i)$ dargestellt werden können. Da $\prod_{i=1}^n (x-z_i)$ ausmultipliziert, in jedem Fall ein normiertes Polynom ergibt, muss $p(x)$ für die Durand-Kerner-Methode ein normiertes Polynom sein.
Ist dies nicht der Fall, wird es unmöglich, $p(x)$ in der Form $\prod_{i=1}^n (x-z_i)$ darzustellen. Daraus folgt, dass man die Methode ohne Umwege nicht ausführen kann. \\
Allerdings gibt es eine einfache Lösung für dieses Problem. Wenn man eine Funktion gleich null setzt, kann man beide Seiten mit einer beliebigen Zahl multiplizieren. Dabei verändert sich das Ergebnis nicht, da $0m = 0$ \space $\forall m$ ist. Daraus folgt, dass sich die Nullstellen eines Polynoms, wenn dieses mit einer beliebigen Zahl multipliziert wird, nicht verändern. \\
Somit kann man das Polynom, dessen Nullstellen man finden möchte, durch $a_n$ teilen und bekommt ein normiertes Polynom mit den gleichen Nullstellen. Mit diesem kann man dann die Durand-Kerner-Methode durchführen.

\subsection{Keine generelle Konvergenz}
Die Durand-Kerner-Methode ist nicht generell Konvergent. Das bedeutet, dass in manchen Fällen die Funktion gegen Unendlich keinen festen Wert anstrebt. Das kann man sich so vorstellen: Jede Nullstelle hat einen Bereich in dem sie von der Weierstraß-Iteration gefunden werden kann. Dieser kann auch ins Unendliche gehen, muss aber nicht. Wenn eine Iteration außerhalb dieses Bereiches geht findet der Wert nicht mehr zu der Nullstelle. Dadurch können auch die anderen Nullstellen nicht konvergieren, da eine der Nullstellen so falsch ist, dass die Korrektur nicht mehr funktioniert. Das führt dazu, dass die Methode nicht konvergiert. Dabei kann nicht generell bestimmt werden, bei welchen Startpunkten und Polynomen die Durand-Kerner-Methode nicht konvergiert. Da dies allerdings sehr selten ist kann es meist vernachlässigt werden.

\section{Implementierung}
\subsection{Einleitung}
Normierung
\subsection{Komplexe Zahlen}
\paragraph{Wieso?????????????????}
In Java gibt es keinen eingebauten Weg mit komplexen Zahlen zu rechnen. Es ist möglich mithilfe einer Bibliothek komplexe Zahlen nutzen zu können, es ist jedoch nicht gegeben, dass alle nötigen Operationen eingebaut sind. Deshalb habe ich mich dazu entschieden eine eigene Klasse \glqq Complex\grqq zu schreiben, um volle Kontrolle über die Methoden und Implementierung der komplexen Zahlen zu haben.

\paragraph{Attribute}
Die Klasse \glqq Complex\grqq besitzt zwei private Attribute (\glqq re\grqq \space und \glqq im\grqq), die den reellen und imaginären Teil der komplexen Zahl darstellen. Beide sind vom Datentyp \glqq double\grqq, um möglichst viele Nachkommastellen repräsentieren zu können.

\paragraph{Konstruktor}
Der Konstruktor der Klasse \glqq Complex\grqq\space nimmt zwei Zahlen (\glqq re\grqq \space und \glqq im\grqq) vom Typ \glqq double\grqq\space entgegen und speichert diese in den beiden Attributen.

\paragraph{Grundrechenarten}
Für die vier Grundrechenarten Addition, Subtraktion, Multiplikation und Division wurden zuerst vier statische Methoden erstellt. Diese nehmen zwei Instanzen der Klasse \glqq Complex\grqq\space als Parameter an und geben das Ergebnis als neue Instanz der gleichen Klasse zurück zurück. Innerhalb der Methoden wird zuerst der reelle und imaginäre Teil des Ergebnisses ausgerechnet.\footnote{ingenieurkurse.de: Höhere Mathematik 1: Analysis und Lineare Algebra: Grundrechenarten der komplexen Zahlen, URL: https://www.ingenieurkurse.de/hoehere-mathematik-analysis-lineare-algebra/komplexe-zahlen/grundrechenarten-der-komplexen-zahlen.html (Stand: 23.10.2023)}
Daraufhin wird die neue Instanz der Klasse \glqq Complex\grqq, mit den zuvor ausgerechneten Werten, erstellt und diese zurückgegeben.

\paragraph{Potenzierung}
Die Potenzierung findet auch mit einer statischen Methode, die eine Instanz der Klasse \glqq Complex\grqq\space zurückgibt, statt. Für die Rechnung wird die Basis als komplexe Zahl und der Exponent als Integer übergeben, daür die Durand-Kerner-Methode wird Potenzierung nur mit natürlichen Zahlen (null eingeschlossen) benötigt, da nur für das Ausrechenen der Polynomfunktion Potenzierung benutzt wird und alle Exponenten einer Polynomfunktion innerhalb der natürlichen Zahlen (null eingeschlossen) sind. Deswegen wird für die Potenzierung der Exponent als Integer übergeben und darauffolgend überprüft ob dieser innerhalb größer oder gleich null ist.


\paragraph{Kleiner Als}


\subparagraph{abs}

\paragraph{Ausgabe}
\subparagraph{toString-Methode}
\subparagraph{runden}

    
\subsubsection{Polynomfunktionen}
\subsubsection{Durand-Kerner für eine Nullstellen}
\subsubsection{Startpunkte}
\subsubsection{Durnad-Kerner für alle Nullstellen}
\subsubsection{Endbedingungen}
\subsubsection{Testen}

\section{Vergleich und Anwendung}

\section{Fazit}

\section{Code}

\begin{lstlisting}[language=Java, title={Complex.java: Z. 19-29}]
    public static Complex plus(Complex a, Complex b) {
            double re = a.re + b.re;
            double im = a.im + b.im;
        return new Complex(re, im);
    }
    
    public static Complex minus(Complex a, Complex b) {
        double re = a.re - b.re;
        double im = a.im - b.im;
        return new Complex(re, im);
    }
    \end{lstlisting}
    
\end{document}